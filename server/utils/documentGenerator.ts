import puppeteer from 'puppeteer';

interface FieldValue {
  [key: string]: string | number;
}

interface DocumentGenerationOptions {
  templateTitle: string;
  templateContent: string;
  fieldValues: FieldValue;
  stateId: string;
}

// HTML escape function to prevent XSS/injection attacks
function escapeHtml(unsafe: string): string {
  return unsafe
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;")
    .replace(/\//g, "&#x2F;");
}

export async function generateDocument(options: DocumentGenerationOptions): Promise<Buffer> {
  const { templateTitle, templateContent, fieldValues, stateId } = options;

  // Create HTML content with filled fields
  const htmlContent = generateHTMLFromTemplate(templateTitle, templateContent, fieldValues, stateId);

  // Launch headless browser
  // NOTE: Using minimal args. Sandbox is enabled by default for security.
  // All user input is HTML-escaped before rendering to prevent injection attacks.
  const browser = await puppeteer.launch({
    headless: true,
    args: [
      '--disable-dev-shm-usage', // Required for containerized environments
      '--disable-gpu' // Not needed for PDF generation
    ]
  });

  try {
    const page = await browser.newPage();
    
    // Set content
    await page.setContent(htmlContent, { waitUntil: 'networkidle0' });

    // Generate PDF
    const pdfBuffer = await page.pdf({
      format: 'Letter',
      printBackground: true,
      margin: {
        top: '0.75in',
        right: '0.75in',
        bottom: '0.75in',
        left: '0.75in',
      }
    });

    return Buffer.from(pdfBuffer);
  } finally {
    await browser.close();
  }
}

function generateHTMLFromTemplate(
  templateTitle: string,
  templateContent: string,
  fieldValues: FieldValue,
  stateId: string
): string {
  // SECURITY: For MVP, we ONLY use default template generation with fully escaped values.
  // templateContent should always be empty. If it's not empty, we ignore it to prevent injection.
  // Future custom templates must use a safe templating engine with auto-escaping.
  
  // Sanitize template title
  const safeTitle = escapeHtml(templateTitle);
  
  // ALWAYS use default template generation (never trust templateContent from database)
  let filledContent = generateDefaultTemplateContent(safeTitle, fieldValues, stateId);
  
  // For safety, still escape any {{fieldId}} placeholders if they exist
  // (though default generator doesn't use this pattern)
  Object.entries(fieldValues).forEach(([fieldId, value]) => {
    const placeholder = new RegExp(`{{${fieldId}}}`, 'g');
    const escapedValue = escapeHtml(String(value));
    filledContent = filledContent.replace(placeholder, escapedValue);
  });

  // Wrap in proper HTML structure with styling
  return `
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${safeTitle}</title>
  <style>
    @page {
      size: Letter;
      margin: 0.75in;
    }
    
    body {
      font-family: 'Georgia', 'Times New Roman', serif;
      font-size: 12pt;
      line-height: 1.6;
      color: #000;
      margin: 0;
      padding: 0;
    }
    
    h1 {
      font-size: 18pt;
      font-weight: bold;
      text-align: center;
      margin-bottom: 24pt;
      text-transform: uppercase;
    }
    
    h2 {
      font-size: 14pt;
      font-weight: bold;
      margin-top: 20pt;
      margin-bottom: 10pt;
      border-bottom: 1px solid #333;
      padding-bottom: 4pt;
    }
    
    h3 {
      font-size: 12pt;
      font-weight: bold;
      margin-top: 16pt;
      margin-bottom: 8pt;
    }
    
    p {
      margin-bottom: 12pt;
      text-align: justify;
    }
    
    .field-value {
      font-weight: bold;
      text-decoration: underline;
    }
    
    .signature-line {
      margin-top: 40pt;
      border-top: 1px solid #000;
      width: 300pt;
      display: inline-block;
    }
    
    .signature-block {
      margin-top: 30pt;
      page-break-inside: avoid;
    }
    
    .footer {
      margin-top: 40pt;
      font-size: 10pt;
      color: #666;
      text-align: center;
      border-top: 1px solid #ccc;
      padding-top: 12pt;
    }
  </style>
</head>
<body>
  ${filledContent}
  
  <div class="footer">
    Document generated by LeaseShield App | ${stateId} | ${new Date().toLocaleDateString()}
  </div>
</body>
</html>
  `;
}

function generateDefaultTemplateContent(
  templateTitle: string,
  fieldValues: FieldValue,
  stateId: string
): string {
  // Generate a default template based on common patterns
  const sections: string[] = [];
  
  sections.push(`<h1>${templateTitle}</h1>`);
  
  // Group fields by category
  const categories = new Map<string, Array<[string, any]>>();
  
  Object.entries(fieldValues).forEach(([fieldId, value]) => {
    // Infer category from field ID (simple heuristic)
    let category = 'General Information';
    if (fieldId.includes('landlord')) category = 'Landlord Information';
    else if (fieldId.includes('tenant')) category = 'Tenant Information';
    else if (fieldId.includes('property')) category = 'Property Details';
    else if (fieldId.includes('rent') || fieldId.includes('deposit') || fieldId.includes('fee')) category = 'Financial Terms';
    else if (fieldId.includes('lease') || fieldId.includes('date')) category = 'Lease Terms';
    
    if (!categories.has(category)) {
      categories.set(category, []);
    }
    categories.get(category)!.push([fieldId, value]);
  });
  
  // Generate sections (with HTML escaping for security)
  categories.forEach((fields, category) => {
    const safeCategory = escapeHtml(category);
    sections.push(`<h2>${safeCategory}</h2>`);
    fields.forEach(([fieldId, value]) => {
      const label = fieldIdToLabel(fieldId);
      const safeLabel = escapeHtml(label);
      const safeValue = escapeHtml(String(value));
      sections.push(`<p><strong>${safeLabel}:</strong> <span class="field-value">${safeValue}</span></p>`);
    });
  });
  
  // Add signature blocks for leases
  if (templateTitle.toLowerCase().includes('lease') || templateTitle.toLowerCase().includes('agreement')) {
    sections.push(`
      <div class="signature-block">
        <h2>Signatures</h2>
        <p>By signing below, the parties acknowledge that they have read, understood, and agree to the terms outlined in this document.</p>
        
        <p style="margin-top: 30pt;">
          <strong>Landlord:</strong><br>
          Signature: <span class="signature-line"></span><br>
          Date: _________________
        </p>
        
        <p style="margin-top: 30pt;">
          <strong>Tenant:</strong><br>
          Signature: <span class="signature-line"></span><br>
          Date: _________________
        </p>
      </div>
    `);
  }
  
  return sections.join('\n');
}

function fieldIdToLabel(fieldId: string): string {
  // Convert camelCase to Title Case
  return fieldId
    .replace(/([A-Z])/g, ' $1')
    .replace(/^./, (str) => str.toUpperCase())
    .trim();
}
